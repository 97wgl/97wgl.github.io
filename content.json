{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/08/23/hello-world/"},{"title":"解特殊指数方程","text":"前几天在牛客上看到一个面试题：y^7 + 0.5y = x，给定x，求y 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.Scanner;/** * y^7 + 0.5y = x，给定x，求y * * 分析：f(y)单调，而且还是奇函数 * * 那么只考虑x &gt; 0的情况： * 由于f(y)单调，故考虑使用二分推出答案 * 并且由原式可知，0.5 * y = x - y ^ 7 &lt; x * ---&gt; 0 &lt; y &lt; 2 * x * */public class 解指数方程 { private final static double ACCURACY = 1e-8; public static void main(String[] args) { Scanner sc = new Scanner(System.in); double x = sc.nextDouble(); if (x == 0) { System.out.println(0); return; } boolean flag = x &gt; 0; x = Math.abs(x); double left = 0, right = 2 * x; while (left &lt; right) { double mid = (right - left) / 2 + left; double diff = calculate(mid) - x; if (Math.abs(diff) &lt;= ACCURACY) { if (!flag) { mid *= -1; } System.out.println(mid); return; } else if (diff &gt; 0) { right = mid; } else { left = mid; } } System.out.println(&quot;no solution&quot;); } private static double calculate(double num) { return Math.pow(num, 7) + 0.5 * num; }}","link":"/2021/08/23/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E8%A7%A3%E7%89%B9%E6%AE%8A%E6%8C%87%E6%95%B0%E6%96%B9%E7%A8%8B/"},{"title":"平方根","text":"求平方根，一般就是用二分法或者牛顿迭代法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.util.Scanner;public class 求算数平方根 { private static final double accuracy = 1e-8; public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { double num = sc.nextDouble(); // 二分 long s1 = System.nanoTime(); double mySqrt = sqrt(num); long e1 = System.nanoTime(); // 牛顿迭代 long s2 = System.nanoTime(); double mySqrtByNewton = sqrtByNewton(num); long e2 = System.nanoTime(); long s3 = System.nanoTime(); double mathSqrt = Math.sqrt(num); long e3 = System.nanoTime(); System.out.printf(&quot;sqrt()：result %.8f\\ttime %d\\n&quot;, mySqrt, e1 - s1); System.out.printf(&quot;sqrtByNewton()：result %.8f\\ttime %d\\n&quot;, mySqrtByNewton, e2 - s2); System.out.printf(&quot;Math.sqrt()：result %.8f\\ttime %d\\n&quot;, mathSqrt, e3 - s3); System.out.printf(&quot;binary equals jdk: %b\\n&quot;, Math.abs(mathSqrt - mySqrt) &lt;= accuracy); System.out.printf(&quot;newton equals jdk: %b\\n&quot;, Math.abs(mathSqrt - mySqrtByNewton) &lt;= accuracy); } } /** * 二分 */ private static double sqrt(double num) { if (num &lt; 0) { throw new RuntimeException(num + &quot;无实根&quot;); } double left = 0, right = num; while (left &lt; right) { double mid = (right - left) / 2 + left; if (Math.abs(mid * mid - num) &lt; accuracy) { return mid; } else if (mid * mid &lt; num) { left = mid; } else { right = mid; } } return 0; } /** * 牛顿迭代 * Xn+1 = (Xn + m / Xn) / 2; */ private static double sqrtByNewton(double num) { double curr = num; double next = (curr + ( num / curr)) / 2; while (Math.abs(next - curr) &gt; accuracy) { curr = next; next = (curr + ( num / curr)) / 2; } return next; }}","link":"/2021/08/23/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B3%E6%96%B9%E6%A0%B9/"}],"tags":[{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"}],"categories":[]}