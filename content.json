{"pages":[],"posts":[{"title":"JVM","text":"深入理解Java虚拟机","link":"/posts/66c016fb/"},{"title":"Zookeeper 搭建伪集群","text":"","link":"/posts/36610/"},{"title":"平方根","text":"求平方根，一般就是用二分法或者牛顿迭代法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.util.Scanner;public class 求算数平方根 { private static final double accuracy = 1e-8; public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { double num = sc.nextDouble(); // 二分 long s1 = System.nanoTime(); double mySqrt = sqrt(num); long e1 = System.nanoTime(); // 牛顿迭代 long s2 = System.nanoTime(); double mySqrtByNewton = sqrtByNewton(num); long e2 = System.nanoTime(); // jdk long s3 = System.nanoTime(); double mathSqrt = Math.sqrt(num); long e3 = System.nanoTime(); System.out.printf(&quot;二分法\\t结果：%.8f\\t耗时：%dns\\n&quot;, mySqrt, e1 - s1); System.out.printf(&quot;牛顿迭代\\t结果：%.8f\\t耗时：%dns\\n&quot;, mySqrtByNewton, e2 - s2); System.out.printf(&quot;JDK\\t结果：%.8f\\t耗时：%dns\\n&quot;, mathSqrt, e3 - s3); } } /** * 二分 */ private static double sqrt(double num) { if (num &lt; 0) { throw new RuntimeException(num + &quot;负数无实平方根&quot;); } double left = 0, right = num; while (left &lt; right) { double mid = (right - left) / 2 + left; if (Math.abs(mid - num / mid) &lt; accuracy) { return mid; } else if (mid &lt; num / mid) { left = mid; } else { right = mid; } } return 0; } /** * 牛顿迭代 * Xn+1 = (Xn + m / Xn) / 2; */ private static double sqrtByNewton(double num) { double curr = num; double next = (curr + ( num / curr)) / 2; while (Math.abs(next - curr) &gt; accuracy) { curr = next; next = (curr + ( num / curr)) / 2; } return next; }} 测试结果：123456789101112131415161718192041789241二分法 结果：6464.45983822 耗时：34400ns牛顿迭代 结果：6464.45983822 耗时：1600nsJDK 结果：6464.45983822 耗时：800ns421421421421二分法 结果：649169.79398382 耗时：3800ns牛顿迭代 结果：649169.79398382 耗时：1100nsJDK 结果：649169.79398382 耗时：200ns421421421422132二分法 结果：20528551.37173912 耗时：4000ns牛顿迭代 结果：20528551.37173912 耗时：1000nsJDK 结果：20528551.37173912 耗时：200ns1200000000二分法 结果：34641.01615138 耗时：3000ns牛顿迭代 结果：34641.01615138 耗时：900nsJDK 结果：34641.01615138 耗时：200ns100000000000000二分法 结果：10000000.00000000 耗时：3700ns牛顿迭代 结果：10000000.00000000 耗时：1100nsJDK 结果：10000000.00000000 耗时：500ns","link":"/posts/43490/"},{"title":"解特殊指数方程","text":"前几天在牛客上看到一个面试题：y^7 + 0.5y = x，给定x，求y 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.Scanner;/** * y^7 + 0.5y = x，给定x，求y * * 分析：f(y)单调，而且还是奇函数 * * 那么只考虑x &gt; 0的情况： * 由于f(y)单调，故考虑使用二分推出答案 * 并且由原式可知，0.5 * y = x - y ^ 7 &lt; x * ---&gt; 0 &lt; y &lt; 2 * x * */public class 解指数方程 { private static double accuracy = 1e-8; public static void main(String[] args) { Scanner sc = new Scanner(System.in); while (sc.hasNext()) { double x = sc.nextDouble(); double y = solve(x); System.out.printf(&quot;x = %f, y = %f\\n&quot;, x, y); } } public static double solve(double x) { if (x == 0) { return 0; } boolean flag = x &gt; 0; x = Math.abs(x); double left = 0, right = x; double mid = 0; while (left &lt; right) { mid = (right - left) / 2 + left; double diff = calculate(mid) - x; if (Math.abs(diff) &lt;= accuracy) { if (!flag) { mid *= -1; } break; } else if (diff &gt; 0) { right = mid; } else { left = mid; } } return mid; } private static double calculate(double num) { return Math.pow(num, 7) + 0.5 * num; }} 测试运行结果：1234567891011121314-100x = -100.000000, y = -1.9280281x = 1.000000, y = 0.9161970x = 0.000000, y = 0.000000100x = 100.000000, y = 1.92802838291x = 38291.000000, y = 4.51569337261.77321x = 37261.773210, y = 4.49815032918429x = 32918429.000000, y = 11.855500","link":"/posts/36610/"},{"title":"统计数组元素出现的次数","text":"123456789101112131415161718192021222324252627282930313233343536public class 统计数字出现次数 { public static void main(String[] args) { int[] arr = {1, 2, 2, 3, 5, 3}; // 核心思想是arr[i] == arr[j] 时，ar[arr[i]]和arr[arr[j]]映射到同一个位置 work(arr, arr.length); int index = 1; for (int countResult : arr) { if (countResult &lt; 0) { System.out.println(index++ + &quot;出现了&quot; + (-1) * countResult + &quot;次&quot;); } } } public static void work(int[] arr, int n) { int index = 0; while (index &lt; n) { // 因为数组都是从0开始的，所以arr[index]得减1才可以找到对应的元素，否则会数组越界 int temp = arr[index] - 1; // 小于0说明当前位置是计数值，直接跳过 if (temp &lt; 0) { index++; continue; } if (arr[temp] &gt; 0) { arr[index] = arr[temp]; arr[temp] = -1; } // 找到自身 else { arr[temp]--; arr[index] = 0; } } }}","link":"/posts/36610/"}],"tags":[{"name":"JAVA","slug":"JAVA","link":"/tags/JAVA/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"二分","slug":"二分","link":"/tags/%E4%BA%8C%E5%88%86/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"}],"categories":[]}